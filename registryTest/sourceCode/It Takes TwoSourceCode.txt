Sun Feb 13 20:20:18 MST 2022
golang
// =============================================================
/*
	CPSC 559 - Iteration 2
	ioUtil.go

	Erick Yip
	Chris Chen
*/

package fileIO

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
)

// Read all files in a directory and return their content as string
// Code was inspired from: https://golang.cafe/blog/how-to-list-files-in-a-directory-in-go.html
func readDirectory(dirName string) string {

	var sourceCode string
	err := filepath.Walk(dirName, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			fmt.Println(err)
			return err
		}

		if !info.IsDir() {
			sourceCode += readFile(path)
		}
		return nil
	})

	if err != nil {
		fmt.Println(err)
	}

	return sourceCode
}

// Format and return a string to match the code response format
func ParseCodeResponse() string {
	var language string = "golang"
	var endOfCode string = "..."

	sourceCode := readDirectory("pkg/")
	sourceCode += readDirectory("cmd/")

	codeResponse := fmt.Sprintf("%s\n%s\n%s\n", language, sourceCode, endOfCode)
	return codeResponse
}

// Read a file's content line-by-line and return it as string, separated by new-lines.
// Code was inspired from the following link: https://golangdocs.com/reading-files-in-golang
func readFile(fileName string) string {
	var sourceCode string = ""
	file, _ := os.Open(fileName)
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		sourceCode += fmt.Sprintf("%s\n", scanner.Text())
	}

	return sourceCode
}

// =============================================================
// =============================================================
/*
	CPSC 559 - Iteration 2
	peerFunc.go

	Erick Yip
	Chris Chen
*/

package peer

import (
	"559Project/pkg/sock"
	"fmt"
)

func InitPeerProcess(address string) {
	conn := sock.InitializeUdpServer(address)

	for {
		msg, addr := sock.ReceiveUdpMessage(address, conn)
		fmt.Println("Received ", msg, " from ", addr)

		switch string(msg[0:4]) {
		case "stop":
			fmt.Println("Received stop command, exiting...")
		case "snip":
			fmt.Println("Received snip command, exiting...")
		case "peer":
			fmt.Println("Received peer command, exiting...")
		}
	}
}

// =============================================================
// =============================================================
/*
	CPSC 559 - Iteration 2
	registryFunc.go

	Erick Yip
	Chris Chen
*/

package registry

import (
	"559Project/pkg/fileIO"
	"559Project/pkg/sock"
	"bufio"
	"fmt"
	"net"
	"strconv"
	"strings"
	"time"
)

// Struct to store the server's address, list of peers, number of peers, and the time the peers are received
type regServer struct {
	address      string
	peerList     []string
	peerNum      int
	timeReceived string
}

func InitRegistryCommunicator(regAddress string, peerAddress string) {
	conn := sock.InitializeTcpClient(regAddress)
	fmt.Printf("Connected to server at %s\n", regAddress)

	var registry regServer = regServer{"", []string{}, 0, ""}
	scanner := bufio.NewScanner(conn)

	var teamName string = "It Takes Two\n" // Our team name

forLoop:
	for {
		serverReply := sock.ReceiveTcpMessage(conn, scanner)

		var clientMessage string

		fmt.Printf("Server message = %s\n", serverReply)

		// Check the server's response and take corresponding actions
		switch {
		case strings.Contains(serverReply, "get team name"):
			clientMessage = "Sending team name...\n"
			sock.SendMessage(teamName, conn)

		case strings.Contains(serverReply, "get code"):
			clientMessage = "Sending code...\n"
			codeResponse := fileIO.ParseCodeResponse()
			sock.SendMessage(codeResponse, conn)

		case strings.Contains(serverReply, "get location"):
			clientMessage = "Sending udp server location...\n"
			sock.SendMessage(peerAddress, conn)

		case strings.Contains(serverReply, "receive peers"):
			registry.address = regAddress
			receivePeers(&registry, conn, scanner)
			clientMessage = "Storing peers...\n"

		case strings.Contains(serverReply, "get report"):
			//TODO: update this
			clientMessage = "Sending report...\n"
			report := generateReport(registry)
			sock.SendMessage(report, conn)

		case strings.Contains(serverReply, "close"):
			fmt.Printf("%s", "Closing...\n")
			conn.Close()
			break forLoop

		default:
			clientMessage = "Unknown message\n"
		}

		fmt.Printf("%s", clientMessage)
	}
}

// Receive the peers from the server and store them into the peerList
func receivePeers(server *regServer, conn net.Conn, scanner *bufio.Scanner) {

	reply := sock.ReceiveTcpMessage(conn, scanner)

	// Convert the number of peers to int
	numPeers, _ := strconv.Atoi(strings.Split(reply, " ")[0])

	fmt.Printf("%d peers received\n", numPeers)

	// Receive the peers
	for i := 0; i < numPeers; i++ {
		// check if the peer is already in the server's peerlist
		peer := sock.ReceiveTcpMessage(conn, scanner)
		if !contains(server.peerList, peer) {
			server.peerList = append(server.peerList, peer)
			server.peerNum++
			fmt.Printf("%s added to peer list\n", peer)
		} else {
			fmt.Printf("%s already in peer list\n", peer)
		}
	}

	server.timeReceived = time.Now().Format("2006-01-02 15:04:05")
}

// Checks if a string is present in a slice
func contains(list []string, str string) bool {
	for _, s := range list {
		if s == str {
			return true
		}
	}
	return false
}

// Generate a report for the list of peers and sources
func generateReport(server regServer) string {

	// Return nothing if no peers have been received (address empty)
	if server.address == "" {
		return "0\n0\n\n0\n"
	}

	// Convert the number of peers to string
	peerNumString := strconv.Itoa(server.peerNum)
	report := fmt.Sprintf("%s\n", peerNumString)

	// Concat the list of peers
	report += concatPeers(server)

	// Format the report
	report += fmt.Sprintf("1\n%s\n%s\n%s\n", server.address, server.timeReceived, peerNumString)

	report += concatPeers(server)

	fmt.Printf("%s", report)

	return report
}

func concatPeers(server regServer) string {
	var peerList string

	for i := 0; i < server.peerNum; i++ {
		peerList += fmt.Sprintf("%s\n", server.peerList[i])
	}

	return peerList
}

// =============================================================
// =============================================================
/*
	CPSC 559 - Iteration 2
	sockUtil.go

	Erick Yip
	Chris Chen
*/

package sock

import (
	"bufio"
	"net"
	"os"
)

// Start the TCP connection to the server
func InitializeTcpClient(address string) net.Conn {
	tcpAddr, err := net.ResolveTCPAddr("tcp", address)
	checkError(err)
	conn, err := net.DialTCP("tcp", nil, tcpAddr)
	checkError(err)
	return conn
}

func InitializeUdpClient(address string) net.Conn {
	udpAddr, err := net.ResolveUDPAddr("udp", address)
	checkError(err)
	conn, err := net.DialUDP("udp", nil, udpAddr)
	checkError(err)
	return conn
}

// https://varshneyabhi.wordpress.com/2014/12/23/simple-udp-clientserver-in-golang/
func InitializeUdpServer(address string) *net.UDPConn {
	udpAddr, err := net.ResolveUDPAddr("udp", address)
	checkError(err)
	conn, err := net.ListenUDP("udp", udpAddr)
	checkError(err)
	return conn
}

func ReceiveUdpMessage(address string, conn *net.UDPConn) (string, string) {

	// Read from the connection
	data := make([]byte, 1024)
	_, addr, err := conn.ReadFromUDP(data)
	checkError(err)
	return string(data), addr.String()

}

//Receive message from the server
func ReceiveTcpMessage(conn net.Conn, scanner *bufio.Scanner) string {
	scanner.Scan()
	return scanner.Text()
}

// Send message to the server
func SendMessage(message string, conn net.Conn) {
	_, err := conn.Write([]byte(message))
	checkError(err)
}

// Check for errors
func checkError(err error) {
	if err != nil {
		println("Error detected, exiting...", err.Error())
		os.Exit(1)
	}
}

// =============================================================
// =============================================================
/*
	CPSC 559 - Iteration 2
	main.go

	Erick Yip
	Chris Chen
*/

package main

import (
	"559Project/pkg/peer"
	"559Project/pkg/registry"
	"fmt"
	"sync"
)

func main() {

	var regAddr, peerAddr string
	var wg sync.WaitGroup

	//ask for the registry and peer process' address
	fmt.Println("Please enter the registry's address: ")
	fmt.Scanln(&regAddr)

	fmt.Println("Please enter the peer process's address: ")
	fmt.Scanln(&peerAddr)

	// Connect to the server via TCP
	wg.Add(2)

	go func() {
		registry.InitRegistryCommunicator(regAddr, peerAddr)
		fmt.Println("Registry Communicator exited")
		wg.Done()
	}()

	go func() {
		peer.InitPeerProcess(peerAddr)
		fmt.Println("Peer Process exited")
		wg.Done()
	}()

	wg.Wait()
}

// =============================================================

